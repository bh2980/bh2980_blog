diff --git a/dist/index-d59451fc.js b/dist/index-d59451fc.js
index fc703c5a29949074cd161c49afad3b1a67c60520..b9ee83f30a36299b8ca10865de72a54691cf0fb5 100644
--- a/dist/index-d59451fc.js
+++ b/dist/index-d59451fc.js
@@ -26834,10 +26834,33 @@ const cursorBuilder = user => {
 };
 function createEditorState(doc, selection, storedMarks, yXmlFragment, awareness) {
   const schema = getEditorSchema(doc.type.schema);
+
+  // ===== 추가: 전역 훅에서 extra plugins 읽기 =====
+  const injected =
+    typeof globalThis !== "undefined" ? globalThis.__KEYSTATIC_EXTRA_PM_PLUGINS__ : undefined;
+
+  const resolved =
+    typeof injected === "function" ? injected(schema) :
+    injected ?? [];
+
+  // 배열만 주면 기본은 beforeKeydown으로 취급
+  const slots = Array.isArray(resolved) ? { beforeKeydown: resolved } : (resolved || {});
+
+  const beforeInput = slots.beforeInput || [];
+  const beforeKeydown = slots.beforeKeydown || [];
+  const afterKeymap = slots.afterKeymap || [];
+  // ============================================
+
   return EditorState.create({
     selection,
     storedMarks,
-    plugins: [pasteLinks(schema), imageDropPlugin(schema), keydownHandler(), ...(yXmlFragment && awareness ? [ySyncPlugin(yXmlFragment), yCursorPlugin(awareness, {
+    plugins: [
+      // (A) paste/drop보다도 먼저
+      ...beforeInput,
+      pasteLinks(schema), imageDropPlugin(schema), 
+      // (B) keydownHandler/keymap보다 먼저(보통 여기 쓰면 됨)
+      ...beforeKeydown,
+      keydownHandler(), ...(yXmlFragment && awareness ? [ySyncPlugin(yXmlFragment), yCursorPlugin(awareness, {
       cursorBuilder,
       awarenessStateFilter(userClientId, clientId, awarenessState) {
         const localState = awareness.getLocalState();
@@ -26849,7 +26872,10 @@ function createEditorState(doc, selection, storedMarks, yXmlFragment, awareness)
     }), inputRules({
       rules: inputRulesForSchema(schema),
       enterRules: enterInputRulesForSchema(schema)
-    }), gapCursor(), keymap(keymapForSchema(schema, !!(yXmlFragment && awareness))), markdocClipboard(), nodeInSelectionDecorations(), placeholderPlugin('Start writing or press "/" for commands…'), reactNodeViews(doc.type.schema), autocompleteDecoration(), tableEditing(), tableCellMenuPlugin(), codeBlockSyntaxHighlighting()],
+    }), gapCursor(), keymap(keymapForSchema(schema, !!(yXmlFragment && awareness))), 
+    // (C) 기본 keymap 이후
+    ...afterKeymap,
+    markdocClipboard(), nodeInSelectionDecorations(), placeholderPlugin('Start writing or press "/" for commands…'), reactNodeViews(doc.type.schema), autocompleteDecoration(), tableEditing(), tableCellMenuPlugin(), codeBlockSyntaxHighlighting()],
     doc
   });
 }
@@ -27404,27 +27430,60 @@ function serializeFromEditorState(value, slug) {
     external
   };
 }
+function getKSMdxHooks() {
+  // 프로젝트에서 globalThis.__KEYSTATIC_MDX_HOOKS__ = { ... } 형태로 주입
+  return globalThis && globalThis.__KEYSTATIC_MDX_HOOKS__;
+}
 function parseToEditorStateMDX(content, schema, files, otherFiles, slug) {
+  const hooks = getKSMdxHooks();
+
+  if (hooks && typeof hooks.beforeParse === 'function') {
+    const next = hooks.beforeParse(content, { slug });
+    if (typeof next === 'string') content = next;
+  }
+
   const root = fromMarkdown(content, {
     extensions: [mdxjs(), gfmAutolinkLiteral(), gfmStrikethrough(), gfmTable()],
     mdastExtensions: [mdxFromMarkdown(), gfmAutolinkLiteralFromMarkdown(), gfmStrikethroughFromMarkdown(), gfmTableFromMarkdown()]
   });
+
   const doc = mdxToProseMirror(root, schema, files, otherFiles, slug);
+
+  if (hooks && typeof hooks.afterParse === 'function') {
+    const next = hooks.afterParse(doc, { slug });
+    if (next) return createEditorState(next);
+  }
+
   return createEditorState(doc);
 }
 function serializeFromEditorStateMDX(value, slug) {
+  const hooks = getKSMdxHooks();
+
   const other = new Map();
   const external = new Map();
-  const mdxNode = proseMirrorToMDXRoot(value.doc, {
+
+  let mdxNode = proseMirrorToMDXRoot(value.doc, {
     extraFiles: other,
     otherFiles: external,
     schema: getEditorSchema(value.schema),
     slug
   });
-  const mdx = toMarkdown(mdxNode, {
+
+  if (hooks && typeof hooks.beforeSerialize === 'function') {
+    const next = hooks.beforeSerialize(mdxNode, { slug });
+    if (next) mdxNode = next;
+  }
+
+  let mdx = toMarkdown(mdxNode, {
     extensions: [gfmAutolinkLiteralToMarkdown(), gfmStrikethroughToMarkdown(), gfmTableToMarkdown(), mdxToMarkdown()],
     rule: '-'
   });
+
+  if (hooks && typeof hooks.afterSerialize === 'function') {
+    const next = hooks.afterSerialize(mdx, { slug });
+    if (typeof next === 'string') mdx = next;
+  }
+
   return {
     content: mdx,
     other,
