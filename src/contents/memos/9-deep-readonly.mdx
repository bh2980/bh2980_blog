---
category: type-script
title: 9 - Deep Readonly
publishedDateTimeISO: 2026-01-05T17:44:00.000Z
tags:
  - type-challenges
  - typescript
---
### 질문

객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 `DeepReadonly<T>`를 구현하세요.

이 챌린지에서는 타입 파라미터 `T`를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요.

예시:

```ts
type X = {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

type Expected = {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`


// !collapse(1:100) collapsed
/* _____________ 테스트 케이스 _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DeepReadonly<X1>, Expected1>>,
  Expect<Equal<DeepReadonly<X2>, Expected2>>,
]

// !collapse(1:21) collapsed
type X1 = {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type X2 = { a: string } | { b: number }

// !collapse(1:21) collapsed
type Expected1 = {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}

type Expected2 = { readonly a: string } | { readonly b: number }
```

### 선행 지식

1. `object`, `Object`, `{}` 타입

   `object` : 원시 타입을 제외한 모든 객체 타입(함수, 배열 등 포함)

   `Object` : JS의 Object에 대응하는 매우 넓은 타입.(실무에서 필터로 사용하기엔 비권장)

   `{}` : `null`과 `undefined`를 제외한 모든 타입
2. 배열의 키

   배열도 객체이므로 `keyof`를 통해 순회 가능하다. <Tooltip content="정확히는 배열의 프로퍼티(length)와 메소드(push)도 포함한다.">이 경우 key는 배열의 index가 된다.</Tooltip>
3. readonly <Tooltip content="배열과 튜플">리스트</Tooltip>

   **할당(대입) 가능성 기준으로**, readonly 리스트 타입은 “쓰기 불필요”라 요구사항이 약하므로 **더 넓다**. 따라서 mutable 리스트는 readonly 리스트에 할당 가능하다.

   <Code codeblock={{"lang":"typescript","value":"any[] extends readonly any[] ? true : false // true"}} />

### 풀이

<Collapsible>
  ```ts
  type DeepReadonly<T> = {
    readonly [K in keyof T]: T[K] extends Function      // 함수 필터링
                                ? T[K] 
                                : T[K] extends object   // 배열, 객체 필터링
                                  ? DeepReadonly<T[K]>  // 재귀
                                  : T[K]                // 원시값은 그대로 사용
  }
  ```
</Collapsible>
