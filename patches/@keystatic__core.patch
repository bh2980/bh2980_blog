diff --git a/dist/index-d59451fc.js b/dist/index-d59451fc.js
index fc703c5a29949074cd161c49afad3b1a67c60520..02c317b1b428462ba75e8960e7452871691015cf 100644
--- a/dist/index-d59451fc.js
+++ b/dist/index-d59451fc.js
@@ -26822,35 +26822,190 @@ function placeholderPlugin(text) {
   });
 }
 
-const cursorBuilder = user => {
-  const cursor = document.createElement('span');
-  cursor.classList.add('ProseMirror-yjs-cursor');
-  cursor.style.borderColor = user.color;
-  const userDiv = document.createElement('div');
-  userDiv.style.backgroundColor = user.color;
-  userDiv.insertBefore(document.createTextNode(user.name), null);
-  cursor.insertBefore(userDiv, null);
-  return cursor;
-};
+// ===============================
+// Wrapper-safe Backspace/Delete handler
+// - No new imports
+// - Intercepts Backspace/Delete ONLY when cursor/selection is inside a wrapper node
+// - Performs ONLY "direct delete" inside wrapper bounds (no joinBackward/joinForward)
+// - Prevents unwrap while still allowing first-character deletion
+// ===============================
+
+function protectWrappersDeleteKeys(schema) {
+  // ✅ wrapper만: reactNodeView가 있고, content가 정확히 'block+'
+  const protectedTypes = new Set(
+    Object.values(schema.nodes).filter(
+      (t) => t.spec.reactNodeView && t.spec.content === "block+"
+    )
+  );
+
+  const nearestProtectedDepth = ($pos) => {
+    for (let d = $pos.depth; d > 0; d--) {
+      if (protectedTypes.has($pos.node(d).type)) return d;
+    }
+    return null;
+  };
+
+  // wrapper 경계 안에서만 delete를 허용
+  const safeDeleteBackward = (state, dispatch, depth) => {
+    const sel = state.selection;
+
+    if (sel instanceof NodeSelection) {
+      deleteSelection(state, dispatch);
+      return true;
+    }
+
+    // selection이 있으면 그냥 selection 삭제(이건 join을 안 탄다)
+    if (!sel.empty) {
+      return deleteSelection(state, dispatch);
+    }
+
+    const $from = sel.$from;
+
+    // wrapper content의 시작/끝
+    const wrapperStart = $from.start(depth); // wrapper 내부 시작
+    // const wrapperEnd = $from.end(depth);    // 필요하면 사용
+
+    const from = sel.from;
+
+    // wrapper 내부 시작점에서 Backspace는 wrapper 경계를 건드리니 막음
+    // (이걸 허용하면 wrapper 밖과 join/unwrap이 발생)
+    if (from <= wrapperStart + 1) return true; // "처리됨"으로 끝내서 기본 로직 못 타게
+
+    // wrapper 안에서만 1 step 삭제
+    if (dispatch) dispatch(state.tr.delete(from - 1, from));
+    return true;
+  };
+
+  const safeDeleteForward = (state, dispatch, depth) => {
+    const sel = state.selection;
+
+    if (sel instanceof NodeSelection) {
+      deleteSelection(state, dispatch);
+      return true;
+    }
+
+    if (!sel.empty) {
+      return deleteSelection(state, dispatch);
+    }
+
+    const $from = sel.$from;
+    const wrapperEnd = $from.end(depth);
+
+    const to = sel.to;
+
+    // wrapper 내부 끝점에서 Delete는 경계 건드리니 막음
+    if (to >= wrapperEnd - 1) return true;
+
+    if (dispatch) dispatch(state.tr.delete(to, to + 1));
+    return true;
+  };
+
+  return new Plugin({
+    props: {
+      // 데스크탑 keydown 경로
+      handleKeyDown(view, event) {
+        const key = event.key;
+        if (key !== "Backspace" && key !== "Delete") return false;
+
+        const state = view.state;
+        const depth = nearestProtectedDepth(state.selection.$from);
+        if (depth == null) return false; // wrapper 밖이면 노터치
+
+        // wrapper 안이면 기본 PM keymap/keydownHandler가 join을 타기 전에 우리가 처리
+        event.preventDefault();
+        event.stopPropagation();
+
+        if (key === "Backspace") {
+          safeDeleteBackward(state, view.dispatch, depth);
+        } else {
+          safeDeleteForward(state, view.dispatch, depth);
+        }
+        return true;
+      },
+
+      // 모바일/IME에서 beforeinput(deleteContent*) 경로
+      handleDOMEvents: {
+        beforeinput(view, event) {
+          const inputType = event && event.inputType;
+          if (
+            inputType !== "deleteContentBackward" &&
+            inputType !== "deleteContentForward"
+          ) {
+            return false;
+          }
+
+          const state = view.state;
+          const depth = nearestProtectedDepth(state.selection.$from);
+          if (depth == null) return false;
+
+          event.preventDefault();
+
+          if (inputType === "deleteContentBackward") {
+            safeDeleteBackward(state, view.dispatch, depth);
+          } else {
+            safeDeleteForward(state, view.dispatch, depth);
+          }
+          return true;
+        },
+      },
+    },
+  });
+}
+
+// ===============================
+// Apply in createEditorState()
+// - Put this BEFORE keydownHandler() and BEFORE keymap(keymapForSchema)
+// ===============================
 function createEditorState(doc, selection, storedMarks, yXmlFragment, awareness) {
   const schema = getEditorSchema(doc.type.schema);
   return EditorState.create({
     selection,
     storedMarks,
-    plugins: [pasteLinks(schema), imageDropPlugin(schema), keydownHandler(), ...(yXmlFragment && awareness ? [ySyncPlugin(yXmlFragment), yCursorPlugin(awareness, {
-      cursorBuilder,
-      awarenessStateFilter(userClientId, clientId, awarenessState) {
-        const localState = awareness.getLocalState();
-        return userClientId !== clientId && awarenessState.location === (localState === null || localState === void 0 ? void 0 : localState.location) && awarenessState.branch === (localState === null || localState === void 0 ? void 0 : localState.branch);
-      }
-    }), yUndoPlugin()] : [history()]), dropCursor({
-      color: tokenSchema.color.alias.borderSelected,
-      width: 2
-    }), inputRules({
-      rules: inputRulesForSchema(schema),
-      enterRules: enterInputRulesForSchema(schema)
-    }), gapCursor(), keymap(keymapForSchema(schema, !!(yXmlFragment && awareness))), markdocClipboard(), nodeInSelectionDecorations(), placeholderPlugin('Start writing or press "/" for commands…'), reactNodeViews(doc.type.schema), autocompleteDecoration(), tableEditing(), tableCellMenuPlugin(), codeBlockSyntaxHighlighting()],
-    doc
+    plugins: [
+      pasteLinks(schema),
+      imageDropPlugin(schema),
+
+      // ✅ 가장 앞쪽에 넣어야 한다 (keydownHandler/keymap보다 먼저 잡아야 함)
+      protectWrappersDeleteKeys(schema),
+
+      keydownHandler(),
+      ...(yXmlFragment && awareness
+        ? [
+            ySyncPlugin(yXmlFragment),
+            yCursorPlugin(awareness, {
+              cursorBuilder,
+              awarenessStateFilter(userClientId, clientId, awarenessState) {
+                const localState = awareness.getLocalState();
+                return (
+                  userClientId !== clientId &&
+                  awarenessState.location === (localState?.location) &&
+                  awarenessState.branch === (localState?.branch)
+                );
+              },
+            }),
+            yUndoPlugin(),
+          ]
+        : [history()]),
+      dropCursor({ color: tokenSchema.color.alias.borderSelected, width: 2 }),
+      inputRules({
+        rules: inputRulesForSchema(schema),
+        enterRules: enterInputRulesForSchema(schema),
+      }),
+      gapCursor(),
+
+      // ✅ 기본 키맵은 그대로 두되, 위 플러그인이 먼저 처리하게 됨
+      keymap(keymapForSchema(schema, !!(yXmlFragment && awareness))),
+
+      markdocClipboard(),
+      nodeInSelectionDecorations(),
+      placeholderPlugin('Start writing or press "/" for commands…'),
+      reactNodeViews(doc.type.schema),
+      autocompleteDecoration(),
+      tableEditing(),
+      tableCellMenuPlugin(),
+      codeBlockSyntaxHighlighting(),
+    ],
+    doc,
   });
 }
 
