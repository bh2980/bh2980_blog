---
status: draft
category: development
title: 블로그라면 SEO는 해봐야지
publishedDateTimeISO: 2026-01-24T23:34:00.000Z
tags:
  - blog
  - nextjs
  - seo
policy:
  discriminant: normal
---
<IdeographicSpace />

<Callout variant="note">
  이 게시글은 Next.js 16 버전 App Router를 기반으로 작성되었습니다.
</Callout>

이 블로그를 개발하면서 꼭 해보자고 생각했던 것이 있습니다. 바로 SEO입니다.

그동안 CSR 위주로 개발해왔던 터라 SEO를 의식해서 개발해 본 경험이 거의 없었습니다. 그래서 이번에는 블로그를 핑계로, SEO에는 어떤 것들이 있고 역할은 무엇인지, 그리고 Next.js에서 이를 어떻게 적용하는지 정리해보려고 합니다.

## SEO는 뭘까?

SEO는 <u>Search Engine Optimization</u>의 줄임말로, 말 그대로 <u>검색 엔진을 위한 최적화</u>를 뜻합니다. 구글이나 네이버 같은 검색 엔진은 웹 사이트를 **발견하고**(Discovery), **가져가서**(Crawling), **색인에 넣고**(Indexing), 중복 URL이 있으면 **대표 주소를 고르는**(Canonicalization) 과정을 거쳐서 검색 결과를 노출합니다.

즉, SEO를 적용한다는 건, 검색 엔진이 이 과정을 수월하게 진행할 수 있도록 필요한 힌트들을 정리해두는 작업이라고 보면 되겠죠. 이를 통해 검색 결과의 더 상위에 노출되고 더 많은 트래픽을 받을 수 있게 될 겁니다.

### On-Page SEO와 Off-Page SEO

SEO는 크게 <Tooltip content="일부에서는 온 페이지 SEO와 기술적 SEO를 구분해서 부르기도 하지만, 여기서는 둘을 합해 온 페이지 SEO로 칭합니다">**온 페이지 SEO**(On-Page SEO)</Tooltip>와 **오프 페이지 SEO**(Off-Page SEO)로 나눌 수 있습니다. 온 페이지 SEO는 title, metadata, sitemap.xml, robots.txt 등 사이트 내부에서 적용하는 SEO를 말하고, 오프 페이지 SEO는 <Tooltip content="다른 웹사이트가 내 웹 사이트 페이지를 걸어주는 링크">백링크</Tooltip>, 브랜딩, 커뮤니티 확산 등 페이지 외부에서 적용되는 SEO를 말합니다.&#x20;

이 글에서는 온 페이지 SEO 중 제가 Next.js에서 직접 적용해 본 항목들만 골라 정리해 보겠습니다.

## Next.js에서 SEO 적용하기

### 1. 도메인 정리

같은 콘텐츠가 여러 도메인에서 열리면, 검색 엔진이 이를 서로 다른 페이지로 인식해서 중복으로 색인하거나, 어느 URL을 대표로 삼을지 혼란이 생길 수 있습니다. 예를 들어 제 블로그는 아래 3개의 도메인으로 접속할 수 있는데요.

* [https://bh2980.dev](https://bh2980.dev)
* [https://www.bh2980.dev](https://www.bh2980.dev)
* [https://bh2980-blog.vercel.app](https://bh2980-blog.vercel.app)

이 경우 `https://bh2980.dev/posts`와 `https://bh2980-blog.vercel.app/posts` 를 각각 다른 url로 인식하여 색인하기 때문에 결과가 분산되는 문제가 생깁니다. 이를 방지하기 위해 대표 도메인으로 정하고 나머지는 모두 `https://bh2980.dev`로 리다이렉트되도록 통일했습니다.

![](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-02-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.41.00.png)

### 2. metadata

메타데이터는 페이지의 내용을 요약해서 설명하는 데이터입니다. 즉, 본문 내용이 아닌 **검색 엔진이나 브라우저가 페이지를 이해하고 표시하는데 사용되는 부가 정보**로, 주로 `<head>` 태그 안에 들어갑니다.

대표적으로 `title` 같은 속성이 있는데요. title이 설정될 경우 브라우저의 탭에 타이틀에 들어간 텍스트가 표시되는 것을 볼 수 있습니다.

```html
<head>
  <title>bh2980.dev</title>
</head>
```

![](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-02-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.39.43.png)

그렇다면 Next.js에서는 이를 어떻게 설정할 수 있을까요? 바로 각 페이지나 레이아웃 파일에서 [`metadata`](https://nextjs.org/docs/app/getting-started/metadata-and-og-images#static-metadata) 객체를 사용하거나 [`generateMetadata`](https://nextjs.org/docs/app/getting-started/metadata-and-og-images#generated-metadata) 함수를 사용하면 됩니다.

<Tabs>
  <Tab label="metadata">
    ```ts title="src/app/posts/page.tsx"
    import type { Metadata } from "next";

    export const metadata: Metadata = {
    	title: "블로그",
    	description: "개발하면서 배운 것들과 경험을 기록합니다.",
    };
    ```
  </Tab>

  <Tab label="generateMetadata">
    ```ts title="src/app/posts/[slug]/page.tsx"
    import type { Metadata } from "next";
    import { getPost } from "@/libs/contents/post";

    export async function generateMetadata({ params }: BlogPageProps): Promise<Metadata> {
    	const { slug } = await params;
    	// @line highlight
    	const post = await getPost(slug);

    	return {
    		title: post.title,
    		description: post.excerpt,
    	};
    }
    ```
  </Tab>
</Tabs>

이 둘의 차이는 **메타 데이터가 정적인지 동적인지의 차이**입니다.&#x20;

저는 글 본문 페이지에 `/posts/[slug]` 형태의 라우트를 사용하기 때문에 글 본문의 페이지 파일에서 정적으로 메타데이터를 결정할 수 없습니다. 이 경우에 `metadata` 객체가 아니라 `generateMetadata`를 사용하면 각 게시글의 정보를 불러와 동적으로 메타 데이터를 생성할 수 있습니다.

만약 메타 데이터를 설정하지 않은 페이지는 기본적으로 **상위 라우트의 메타 데이터를 상속**받습니다. 그래서 앱 루트 라우트 혹은 레이아웃 파일에서 기본 설정을 해두고, 필요한 라우트에만 다시 설정해주면 편합니다.

```ts title="src/app/layout.tsx"
export async function generateMetadata(): Promise<Metadata> {
	return {
		// @line highlight
		metadataBase: "https://bh2980.dev",
		title: "bh2980.dev",
		description: "bh2980의 개발 블로그",
	};
}
```

여기서 한 가지 특이한 속성이 있는데 바로 `metadataBase`입니다. 이 속성은 canonical, alternates, openGraph, twitter 등 **절대 URL이 필요한 메타데이터에서 상대 경로를 사용할 수 있게 해주는 기준 URL**로, `/posts` 같은 값을 자동으로 `https://bh2980.dev/posts` 형태의 절대 URL로 변환해줍니다. 설정해두면 편해서 해두는 것을 추천합니다.

<Callout variant="info">
  메타데이터 설정 시 타이틀에 [템플릿](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#template)을 설정할 수 있습니다.&#x20;

  템플릿을 설정할 경우, 하위 라우트에서 작성한 타이틀이 템플릿에 들어가는 형태로 표시됩니다.&#x20;

  하위 라우트에서 템플릿을 사용하고 싶지 않을 경우 [`absolute`](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#absolute) 속성을 사용할 수 있습니다.
</Callout>

### 3. canonical

```html
<link rel="canonical" href="https://bh2980.dev/posts">
```

캐노니컬(canonical) 태그는 동일하거나 거의 동일한 콘텐츠를 가리키는 여러 URL 중에서 **검색엔진이 대표로 인식해야 할 URL을 지정하는 태그**입니다.

예를 들어 제 블로그의 글 목록 페이지는 category 기준으로 필터링할 수 있으며, 이 과정에서 category 쿼리 스트링이 URL에 추가됩니다.

* [https://bh2980.dev/posts](https://bh2980.dev/posts)
* [https://bh2980.dev/posts?category=development](https://bh2980.dev/posts?category=development)

이 둘은 사용자에게는 분명히 다른 페이지이지만, 검색엔진 입장에서는 동일한 글 목록 페이지의 변형에 불과하므로 색인과 평가는 하나의 URL로 통합하는 편이 합리적입니다. 이럴 때 바로 캐노니컬 태그를 사용합니다.

Next.js에서 캐노니컬의 값은 앞서 작성한 메타데이터의 `alternates` 속성에서 정의할 수 있습니다.

```ts title="src/app/posts/page.tsx"
export const metadata: Metadata = {
	title: "블로그",
	description: "개발하면서 배운 것들과 경험을 기록합니다.",
	// @line plus
	alternates: { canonical: `/posts` },
};
```

위와 같이 설정하면 `/posts` 페이지를 기준으로 `<link rel="canonical">` 태그가 자동으로 생성되며, 쿼리 스트링이 붙은 URL들은 검색엔진 관점에서 모두 `/posts`의 변형으로 인식되어 색인과 평가 기준이 하나의 URL로 통합됩니다.

### 4. robots.txt

robots.txt는 **검색 엔진 크롤러가 어떤 경로를 크롤링 할 수 있는지 제어하는 역할**을 합니다. 사이트의 루트 경로인 `/robots.txt`에 위치하고, 크롤러는 이 파일을 먼저 확인한 뒤 페이지를 탐색합니다.&#x20;

예를 들어, 검색 결과에 노출될 필요가 없는 admin 페이지나 API 경로가 존재하는 경우가 존재할 경우, 이를 Disallow에 등록하면  해당 경로는 크롤링 대상에서 제외됩니다. 다만 이는 접근을 아예 차단하는 설정이 아니라, 크롤러에게 해당 경로를 탐색하지 말도록 안내하는 규칙에 가깝습니다.

<Tabs>
  <Tab label="robots.txt">
    ```text title="src/app/robots.txt"
    // @char Tooltip {0-12} content="모든 검색엔진 크롤러를 대상으로 규칙 적용"
    User-Agent: *
    // @char Tooltip {0-7} content="루트 경로(/) 이하의 모든 경로에 대한 크롤링을 기본적으로 허용"
    Allow: /
    // @char Tooltip {0-20} content="/keystatic/ 경로 이하의 모든 파일 및 하위 경로에 대한 크롤링을 차단"
    Disallow: /keystatic/
    Disallow: /api/
    ```
  </Tab>

  <Tab label="robots.ts">
    ```ts title="src/app/robots.ts"
    import type { MetadataRoute } from "next";

    export default function robots(): MetadataRoute.Robots {
    	return {
    		rules: {
    			userAgent: "*",
    			allow: "/",
    			disallow: ["/keystatic/", "/api/"],
    		},
    	};
    }
    ```
  </Tab>
</Tabs>

Next.js에서는 `src/app` 디렉터리에 `robots.txt` 또는 `robots.ts` 파일을 추가하면, 빌드 결과로 사이트 루트에 해당 파일이 생성됩니다.

이 역시 메타 데이터와 마찬가지로 정적으로 정의할 경우 txt 파일로 정의하면 되고, 동적인 값이 필요한 경우 `robots` 함수를 활용해 정의 할 수 있습니다.&#x20;

두 방식 모두 최종적으로 동일한 robots.txt를 생성합니다. 특별히 동적인 값이 필요하지 않다면 정적 파일만으로도 충분하지만, 저는 타입 지원과 일관된 메타데이터 관리 방식을 유지하기 위해 robots 함수를 사용하는 방식을 선택했습니다.

<Callout variant="info">
  기존의 robots.txt와 별개로 메타 데이터에서 작성할 수 있는 [robots 속성](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#robots)도 존재합니다. robots.txt가 사이트 전체에 대한 크롤링 정책을 설정한다면, \
  메타 데이터의 robots 속성은 **페이지별 색인 여부와 링크 추적 여부를 설정**한다는 점에서 다릅니다.

  ```ts
  const metadata = {
  	title: "Not Found",
  	robots: { index: false, follow: true },
  }
  ```
</Callout>

### 5. sitemap.xml

robots.txt가 크롤러에게 페이지의 크롤링 정책을 안내하는 역할이라면, sitemap.xml은 사이트 내에서 크롤링 및 색인이 이루어지길 원하는 URL 목록을 검색엔진에 전달하는 역할을 합니다. 즉, robots.txt와는 상호보완적 관계라고 할 수 있겠죠.

Next.js에서 사이드맵을 작성할 때 이전과 마찬가지로 정적으로 적을 수도, 동적으로 적을 수도 있습니다만, 정적으로 적는 것은 추천하지 않습니다. 사이트맵에 적어야하는 파일이 많고 추가될 때마다 수정해주어야하기 때문에 누락이나 실수할 가능성이 높기 때문입니다.

```ts title="src/app/sitemap.ts"
import type { MetadataRoute } from "next";
import { getPostList } from "@/libs/contents/post";

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
	const posts = await getPostList();

	const postsSitemap = posts.list.map<MetadataRoute.Sitemap[number]>((post) => ({
		url: new URL(`https://bh2980.dev/posts/${post.slug}`).toString(),
		// @char Tooltip {2-30} content="lastModified에 들어가는 날짜의 형식은 ISO 8601 형식을 따라야합니다."
		lastModified: post.updatedAt,
	}));

	return [
		{
			url: 'https://bh2980.dev',
		},
		{
			url: `https://bh2980.dev/posts`,
		},
		...postsSitemap,
	];
}
```

저는 Next.js에서 제공하는 sitemap 함수에 게시글과 메모 리스트를 가져와 넣어주는 방식으로 작성했는데요. url과 필요한 정보가 있는 배열을 return하면 간편하게 사이트맵을 생성할 수 있습니다.&#x20;

sitemap 함수를 이용하면 게시글이 추가될 때마다 사이트맵이 함께 갱신되므로, 수동으로 관리할 때 발생할 수 있는 누락 가능성을 줄일 수 있습니다.

<Callout variant="info">
  하나의 사이트맵에 들어갈 수 있는 URL의 개수는 최대 50,000개입니다. 때문에 50,000개 이상의 URL을 사이트맵에 담으려면 [`generateSitemaps`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#generating-multiple-sitemaps) 함수를 이용해서 사이트맵을 여러 개로 분할해 만들 필요가 있습니다.
</Callout>

이렇게 만든 사이트맵 파일은 사이트의 루트 경로에서 찾아볼 수 있습니다.

```svelte title="sitemap.xml"
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
	<url>
		<loc>https://bh2980.dev</loc>
	</url>
	<url>
		<loc>https://bh2980.dev/posts</loc>
	</url>
	<url>
		<loc>https://bh2980.dev/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C</loc>
		<lastmod>2026-01-02T18:42+09:00</lastmod>
	</url>
	...
</urlset>
```

마지막으로 만든 사이트맵을 robots.txt에 등록해주어 검색 엔진이 사이트맵이 어디있는지 쉽게 찾을 수 있도록 설정해주면 좋습니다.

```ts title="src/app/robots.ts"
import type { MetadataRoute } from "next";

export default function robots(): MetadataRoute.Robots {
	return {
		rules: {
			userAgent: "*",
			allow: "/",
			disallow: ["/keystatic/", "/api/"],
		},
		// @line plus
		sitemap: `https://bh2980.dev/sitemap.xml`,
	};
}
```

### 6. OpenGraph

![](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-02-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.38.05.png)

OpenGraph, 흔히 OG 태그라고 부르는 메타데이터는 링크를 공유할 때 표시되는 **미리보기 카드(제목, 설명, 대표 이미지 등)의 내용을 정의**합니다. 카카오톡이나 디스코드, X(트위터) 같은 서비스는 페이지의 `<head>`에 포함된 OpenGraph 정보를 읽어, 링크를 카드 형태로 표시합니다.

OG 태그는 robots.txt나 sitemap.xml처럼 검색 엔진의 크롤링이나 색인을 직접 제어하는 요소는 아니지만, 공유 시점에 어떤 제목과 설명, 이미지를 보여줄지를 결정하기 때문에 클릭률 등 <u>간접적으로 SEO에 기여</u>한다고 볼 수 있습니다.

Next.js에서는 메타데이터의 `openGraph` 속성을 정의해 OG 정보를 설정할 수 있습니다. 저는 루트 레이아웃에서 기본 값을 설정해두고, 게시글 상세 페이지에서는 `generateMetadata`를 사용해 각 게시글의 제목과 요약을 OG에 반영하는 방식으로 구성했습니다.

```ts title="src/app/posts/[slug]/page.tsx"
export async function generateMetadata({ params }: BlogPageProps): Promise<Metadata> {
	const { slug } = await params;
	const post = await getPost(slug);

	return {
		title: post.title,
		description: post.excerpt,
		alternates: { canonical: `posts/${slug}` },
		// @line plus
		openGraph: {
			title: post.title,
			description: post.excerpt,
			url: `/posts/${slug}`,
		},
		// @line plus end
	};
}
```

<IdeographicSpace />

<Callout variant="info">
  openGraph 속성의 title과 description 속성을 지정하지 않을 경우, 메타 데이터의 title, description 속성을 상속 받습니다.
</Callout>

OpenGraph에는 중요한 항목이 하나 더 남아있습니다. 바로 대표 이미지인데요. 대표 이미지 역시 [정적 방식](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#image-files-jpg-png-gif)과 동적 방식 중 필요한 방식으로 설정할 수 있습니다.

```ts
import { ImageResponse } from "next/og";

export const size = { width: 1200, height: 630 };
export const contentType = "image/png";

export default async function Image() {
  return new ImageResponse(
    <div style={{ fontSize: 64, display: "flex", width: "100%", height: "100%", alignItems: "center", justifyContent: "center" }}>
      bh2980.dev
    </div>,
    { width: 1200, height: 630 }
  );
}
```
