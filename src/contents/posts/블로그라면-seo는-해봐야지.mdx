---
status: draft
category: development
title: 블로그라면 SEO는 해봐야지
publishedDateTimeISO: 2026-01-24T23:34:00.000Z
tags:
  - blog
  - nextjs
  - seo
policy:
  discriminant: normal
---
이 블로그를 개발하면서 꼭 해보자고 생각했던 것이 있습니다. 바로 SEO입니다.

그동안 CSR 위주로 개발해왔던 터라 SEO를 의식해서 개발해 본 경험이 거의 없었습니다. 그래서 이번에는 블로그를 핑계로, SEO에는 어떤 것들이 있고 역할은 무엇인지, 그리고 Next.js에서 이를 어떻게 적용하는지 정리해보려고 합니다.

## SEO는 뭘까?

SEO는 <u>Search Engine Optimization</u>의 줄임말로, 말 그대로 <u>검색 엔진을 위한 최적화</u>를 뜻합니다. 구글이나 네이버 같은 검색 엔진은 웹 사이트를 **발견하고**(Discovery), **가져가서**(Crawling), **색인에 넣고**(Indexing), 중복 URL이 있으면 **대표 주소를 고르는**(Canonicalization) 과정을 거쳐서 검색 결과를 노출합니다.

즉, SEO를 적용한다는 건, 검색 엔진이 이 과정을 수월하게 진행할 수 있도록 필요한 힌트들을 정리해두는 작업이라고 보면 되겠죠. 이를 통해 검색 결과의 더 상위에 노출되고 더 많은 트래픽을 받을 수 있게 될 겁니다.

### On-Page SEO와 Off-Page SEO

SEO는 크게 <Tooltip content="일부에서는 온 페이지 SEO와 기술적 SEO를 구분해서 부르기도 하지만, 여기서는 둘을 합해 온 페이지 SEO로 칭합니다">**온 페이지 SEO**(On-Page SEO)</Tooltip>와 **오프 페이지 SEO**(Off-Page SEO)로 나눌 수 있습니다. 온 페이지 SEO는 title, metadata, sitemap.xml, robots.txt 등 사이트 내부에서 적용하는 SEO를 말하고, 오프 페이지 SEO는 <Tooltip content="다른 웹사이트가 내 웹 사이트 페이지를 걸어주는 링크">백링크</Tooltip>, 브랜딩, 커뮤니티 확산 등 페이지 외부에서 적용되는 SEO를 말합니다.&#x20;

이 글에서는 온 페이지 SEO 중 제가 Next.js에서 직접 적용해 본 항목들만 골라 정리해 보겠습니다.

## Next.js에서 SEO 적용하기

### 1. 도메인 정리

같은 콘텐츠가 여러 도메인에서 열리면, 검색 엔진이 이를 서로 다른 페이지로 인식해서 중복으로 색인하거나, 어느 URL을 대표로 삼을지 혼란이 생길 수 있습니다. 예를 들어 제 블로그는 아래 3개의 도메인으로 접속할 수 있는데요.

* [https://bh2980.dev](https://bh2980.dev)
* [https://www.bh2980.dev](https://www.bh2980.dev)
* [https://bh2980-blog.vercel.app](https://bh2980-blog.vercel.app)

이 경우 `https://bh2980.dev/posts`와 `https://bh2980-blog.vercel.app/posts` 를 각각 다른 url로 인식하여 색인하기 때문에 결과가 분산되는 문제가 생깁니다. 이를 방지하기 위해 대표 도메인으로 정하고 나머지는 모두 `https://bh2980.dev`로 <Tooltip content="308은 영구 Redirect를 의미">리다이렉트</Tooltip>되도록 통일했습니다.

!\[vercel 설정을 통해 도메인을 통일한 모습]\()

### 2. metadata 자동화

메타데이터는 페이지의 내용을 요약해서 설명하는 데이터입니다. 즉, 본문 내용이 아닌 **검색 엔진이나 브라우저가 페이지를 이해하고 표시하는데 사용되는 부가 정보**로, 주로 `<head>` 태그 안에 들어갑니다.

대표적으로 `title` 같은 속성이 있는데요. title이 설정될 경우 브라우저의 탭에 타이틀에 들어간 텍스트가 표시되는 것을 볼 수 있습니다.

```html
<head>
  <title>bh2980.dev</title>
</head>
```

!\[브라우저 탭에 title이 들어간 모습]\()

그렇다면 Next.js에서는 이를 어떻게 설정할 수 있을까요? 바로 각 페이지나 레이아웃 파일에서 [`metadata`](https://nextjs.org/docs/app/getting-started/metadata-and-og-images#static-metadata) 객체를 사용하거나 [`generateMetadata`](https://nextjs.org/docs/app/getting-started/metadata-and-og-images#generated-metadata) 함수를 사용하면 됩니다.

<Tabs>
  <Tab label="metadata">
    ```ts title="src/app/posts/page.tsx"
    import type { Metadata } from "next";

    export const metadata: Metadata = {
    	title: "블로그",
    	description: "개발하면서 배운 것들과 경험을 기록합니다.",
    };
    ```
  </Tab>

  <Tab label="generateMetadata">
    ```ts title="src/app/posts/[slug]/page.tsx"
    import type { Metadata } from "next";
    import { getPost } from "@/libs/contents/post";

    export async function generateMetadata({ params }: BlogPageProps): Promise<Metadata> {
    	const { slug } = await params;
    	// @line highlight
    	const post = await getPost(slug);

    	return {
    		title: post.title,
    		description: post.excerpt,
    	};
    }
    ```
  </Tab>
</Tabs>

이 둘의 차이는 **메타 데이터가 정적인지 동적인지의 차이**입니다.&#x20;

저는 글 본문 페이지에 `/posts/[slug]` 형태의 라우트를 사용하기 때문에 글 본문의 페이지 파일에서 정적으로 메타데이터를 결정할 수 없습니다. 이 경우에 `metadata` 객체가 아니라 `generateMetadata`를 사용하면 각 게시글의 정보를 불러와 동적으로 메타 데이터를 생성할 수 있습니다.

만약 메타 데이터를 설정하지 않은 페이지는 기본적으로 **상위 라우트의 메타 데이터를 상속**받습니다. 그래서 최상위 라우트 혹은 레이아웃 파일에서 기본 설정을 해두고, 필요한 라우트에만 다시 설정해주면 편합니다.

```ts title="src/app/layout.tsx"
export async function generateMetadata(): Promise<Metadata> {
	return {
		// @line highlight
		metadataBase: "https://bh2980.dev",
		title: "bh2980.dev",
		description: "bh2980의 개발 블로그",
	};
}
```

여기서 한 가지 특이한 속성이 있는데 바로 `metadataBase`입니다. 이 속성은 canonical, alternates, openGraph, twitter 등 **절대 URL이 필요한 메타데이터에서 상대 경로를 사용할 수 있게 해주는 기준 URL**로, `/posts` 같은 값을 자동으로 `https://bh2980.dev/posts` 형태의 절대 URL로 변환해줍니다. 설정해두면 편해서 해두는 것을 추천합니다.

<Callout variant="note">
  ```ts title="src/app/layout.tsx"
  import type { Metadata } from 'next'

  export const metadata: Metadata = {
  	title: {
  		// @line highlight
  		template: '%s | bh2980.dev',
  		default: 'bh2980.dev',
  	},
  }
  ```

  \
  메타데이터 설정 시 타이틀에 템플릿을 설정할 수 있습니다.&#x20;

  템플릿을 설정할 경우, 하위 라우트에서 작성한 타이틀이 템플릿에 들어가는 형태로 표시됩니다.&#x20;

  하위 라우트에서 템플릿을 사용하고 싶지 않을 경우 `absolute` 속성을 사용할 수 있습니다.

   

  <Tabs>
    <Tab label="결과">
      ```ts title="src/app/posts/page.tsx"
      import type { Metadata } from "next";

      export const metadata: Metadata = {
      	// @line highlight
      	title: "블로그", // "블로그 | bh2980.dev"
      	description: "개발하면서 배운 것들과 경험을 기록합니다.",
      };
      ```
    </Tab>

    <Tab label="Absolute 사용">
      ```ts title="src/app/posts/page.tsx"
      import type { Metadata } from "next";

      export const metadata: Metadata = {
      	// @line highlight
      	title: {
      		absolute: "블로그" // "블로그"
      	},
      	// @line highlight end
      	description: "개발하면서 배운 것들과 경험을 기록합니다.",
      };
      ```
    </Tab>
  </Tabs>
</Callout>

### 3. Canonical 태그

```html
<link rel="canonical" href="https://bh2980.dev/posts">
```

캐노니컬(canonical) 태그는 동일하거나 거의 동일한 콘텐츠를 가리키는 여러 URL 중에서 **검색엔진이 대표로 인식해야 할 URL을 지정하는 태그**입니다.&#x20;

예를 들어 제 블로그의 글 목록 페이지는 category 기준으로 필터링할 수 있으며, 이 과정에서 category 쿼리 스트링이 URL에 추가됩니다.

* [https://bh2980.dev/posts](https://bh2980.dev/posts)
* [https://bh2980.dev/posts?category=development](https://bh2980.dev/posts?category=development)

이 둘은 사용자에게는 분명히 다른 페이지이지만, 검색엔진 입장에서는 동일한 글 목록 페이지의 변형에 불과하므로 색인과 평가는 하나의 URL로 통합하는 편이 합리적입니다. 이럴 때 바로 캐노니컬 태그를 사용합니다.

Next.js에서 캐노니컬의 값은 앞서 작성한 메타데이터의 `alternates` 속성에서 정의할 수 있습니다.

```ts title="src/app/posts/page.tsx"
export async function generateMetadata(): Promise<Metadata> {
	const HOST_URL = process.env.HOST_URL;
	if (!HOST_URL) throw new Error("HOST_URL is required");

	return {
		metadataBase: new URL(HOST_URL),
		title: "bh2980.dev",
		description: "bh2980의 개발 블로그",
		alternates: { canonical: "/" },
	};
}
```

위와 같이 설정하면 `/posts` 페이지를 기준으로 `<link rel="canonical">` 태그가 자동으로 생성되며, `/posts?category=development`와 같은 쿼리 스트링이 붙은 URL들은 검색엔진 관점에서 모두 `/posts`의 변형으로 인식되어 색인과 평가 기준이 하나의 URL로 통합됩니다.
