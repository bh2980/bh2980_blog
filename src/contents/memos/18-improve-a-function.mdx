---
category: java-script
title: 18. Improve a function
publishedDateTimeISO: 2026-01-09T12:20:00.000Z
tags:
  - bfedev
  - javascript
---
## 문제

아래 함수를 보고 제시된 질문에 답변을 해주세요.

<Code codeblock={{"lang":"typescript","value":"// Given an input of array, \n// which is made of items with >= 3 properties\nlet items = [\n  {color: 'red', type: 'tv', age: 18}, \n  {color: 'silver', type: 'phone', age: 20},\n  {color: 'blue', type: 'book', age: 17}\n] \n// an exclude array made of key value pair\nconst excludes = [ \n  {k: 'color', v: 'silver'}, \n  {k: 'type', v: 'tv'}, \n  ...\n] \nfunction excludeItems(items, excludes) { \n  excludes.forEach( pair => { \n    items = items.filter(item => item[pair.k] === item[pair.v])\n  })\n \n  return items\n}"}} />



1. `excludeItems` 함수는 어떤 역할을 하나요?
2. 함수가 기대대로 동작하나요?
3. 현재 함수의 시간 복잡도는 어떤가요?
4. 어떻게 최적화 할 수 있을까요?



## 선행 지식

1. `Object.entries()` vs `Set.prototype.entries()`

   `Object.entries()`는 새로운 배열을 만들어서 return하는 반면, `Set.prototype.entries()`는 순회할 수 있도록 만드는 이터레이터 객체를 만들어 return한다.



## 풀이

<Collapsible>
  <Code codeblock={{"lang":"typescript","value":"function excludeItems(items, excludes) {\n  const excludeItemMap = excludes.reduce((acc, {k, v}) => {\n    if(acc.has(k)){\n      acc.get(k).add(v)\n\n      return acc;\n    }\n\n    acc.set(k, new Set([v]));\n\n    return acc;\n  }, new Map());\n\n  const newItems = items.filter(item => {\n    for(const k of excludeItemMap.keys()){\n      const vSet = excludeItemMap.get(k);\n      \n      if(vSet.has(item[k])){\n        return false;\n      }\n    }\n\n    return true;\n  })\n\n  return newItems\n}"}} />



  1. `excludeItems` 함수는 어떤 역할을 하나요?

     excludes함수는 전체 아이템 배열과 제외할 아이템의 키와 값을 담은 배열을 받아 하나라도 제외 속성과 일치하는 값을 가진 아이템을 제외한 배열을 return합니다.
  2. 함수가 기대대로 동작하나요?

     아니요. \
     먼저, filter가 `===` 연산자를 사용함으로써 제외 속성을 가진 아이템만 필터링하도록 설정되어있습니다.\
     둘째로 아이템의 값 `v`를 `item[pair.v]`로 key로 사용하고 있어 정상적인 비교가 이루어지지 않습니다.
  3. 현재 함수의 시간 복잡도는 어떤가요?

     `items` 배열의 길이를 `I`, `excludes`의 배열의 길이를 `E`라고 하면 `O(E * I)`입니다.
  4. 어떻게 최적화 할 수 있을까요?

     `excludes`를 먼저 순회하면서 `Map<string, Set>` 형태의 객체를 먼저 만들고, 이후 `items`를 순회하면서 제외 키 값에 해당하는 값을 `item`으로부터 꺼내어 `set`에 있는지 비교합니다.\
     이 때, 제외 키들의 개수를 `K`라고 하면, 전체 시간 복잡도는 `O(E + I * K)`입니다.


</Collapsible>

