---
title: 15. implement a simple DOM wrapper to support method chaining like jQuery
publishedDateTimeISO: 2026-01-07T13:13:00.000Z
tags:
  - bfedev
  - javascript
  - snippets
---
## 문제

jQuery 처럼 속성을 chaining해서 설정할 수 있는 wrapper `$`를 만들어주세요.

<Code codeblock={{"lang":"typescript","value":"$('#button')\n  .css('color', '#fff')\n  .css('backgroundColor', '#000')\n  .css('fontWeight', 'bold')"}} />

## 풀이

<Collapsible>
  <PureMdx
    source="<CodeWithTooltips>

```js !code
function $(el) {
&nbsp;&nbsp;const element = el

&nbsp;&nbsp;return {
&nbsp;&nbsp;&nbsp;&nbsp;// !tooltip[/function/] function
&nbsp;&nbsp;&nbsp;&nbsp;css: function(propertyName, value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// !tooltip[/\[propertyName\]/] propertyName
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.style[propertyName] = value;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// !tooltip[/this\.css/] css
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;css: this.css
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
}
```

## !!tooltips function

this 바인딩을 위한 일반 함수 호출

## !!tooltips propertyName

동적으로 객체 키를 설정하기 위해 대괄호를 통한 객체 키 접근

## !!tooltips css

이 때 this는 function 키워드를 통해 호출한 객체를 이어 받는다.

</CodeWithTooltips>"
  />

  <Collapsible>
    <Mermaid chart="graph TD; A[&#x22;$(el) 단독 호출&#x22;]-->B[&#x22;$ 실행 컨텍스트 생성&#x22;]; B-->C[&#x22;$의 this = undefined (strict/module)&#x22;]; C-->D[&#x22;return { css: ... } 평가&#x22;]; D-->E{&#x22;css 함수 종류?&#x22;}; E--&#x22;화살표 함수&#x22;-->F[&#x22;css(arrow) 함수 객체 생성&#x22;]; F-->G[&#x22;상위 컨텍스트($)의 this 캡처/고정 (= undefined)&#x22;]; G-->H[&#x22;receiver = $(el)의 반환 객체&#x22;]; H-->I[&#x22;receiver.css(...) 호출&#x22;]; I-->J[&#x22;receiver를 this로 전달 시도&#x22;]; J-->K[&#x22;arrow는 호출 this를 받지 않음&#x22;]; K-->L[&#x22;캡처된 this(= undefined) 사용&#x22;]; E--&#x22;일반 function&#x22;-->M[&#x22;css(function) 함수 객체 생성 (this 캡처 없음)&#x22;]; M-->N[&#x22;receiver = $(el)의 반환 객체&#x22;]; N-->O[&#x22;receiver.css(...) 호출&#x22;]; O-->P[&#x22;엔진이 this = receiver로 설정 후 실행&#x22;];" />

    1. $(el) 호출
    2. $의 **실행 컨텍스트(execution context)** 가 생성되고, 단독 호출이라 $의 this가 undefined로 결정(대부분 strict 환경)
    3. 화살표 함수
       1. return \{ css: (...) } 객체 리터럴을 **평가하는 순간** css의 **화살표 함수 객체가 생성**되고, 그때 상위 실행 컨텍스트($)의 this(이때는 undefined)를 **캡처**해서 고정
       2. $(el).css('color', '#fff') 실행 시 엔진은 메소드 호출 형태이므로 css에 $(el)의 반환 객체를 this로 지정하려고 시도하지만, 화살표 함수에는 호출로부터 this를 받는 매커니즘이 없어서 무시된다.
    4. function 함수
       1. css객체는 생성되지만 this는 고정하지 않는다. 이는 호출 시점에 결정된다.
       2. $(el).css('color', '#fff')를 호출하는 순간 엔진이 $(el)의 반환 객체를 css의 this로 지정하여 css 함수를 실행한다.
  </Collapsible>
</Collapsible>
