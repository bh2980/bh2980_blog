---
category: type-script
title: XXX - Equal
publishedDateTimeISO: 2026-01-04T23:24:00.000Z
tags:
  - typescript
  - type-challenges
---
<Callout variant="note">
  이 문항은 Type Challenges에 존재하지 않는 문항입니다.
</Callout>

### 질문

두 타입이 완전히 동일한지 비교하는 `Equal<A, B>` 타입을 구현하세요.

예시:

```ts
type A = Equal<1, 1>            // true
type B = Equal<1, number>       // false
type C = Equal<true, boolean>   // false
type D = Equal<{ a: number }, { a: number }> // true
type E = Equal<{ a: number }, { readonly a: number }> // false

/* _____________ 테스트 케이스 _____________ */
import type { Expect } from ‘@type-challenges/utils’

type cases = [
// primitive & literal
Expect<Equal<Equal<1, 1>, true>>,
Expect<Equal<Equal<1, number>, false>>,
Expect<Equal<Equal<‘a’, ‘a’>, true>>,
Expect<Equal<Equal<‘a’, string>, false>>,

// boolean
Expect<Equal<Equal<true, true>, true>>,
Expect<Equal<Equal<true, boolean>, false>>,
Expect<Equal<Equal<boolean, boolean>, true>>,

// union
Expect<Equal<Equal<1 | 2, 1 | 2>, true>>,
Expect<Equal<Equal<1 | 2, 2 | 1>, true>>,
Expect<Equal<Equal<1 | 2, 1>, false>>,
Expect<Equal<Equal<1, 1 | 2>, false>>,

// object
Expect<Equal<Equal<{ a: number }, { a: number }>, true>>,
Expect<Equal<Equal<{ a: number }, { readonly a: number }>, false>>,
Expect<Equal<Equal<{ a: number }, { a: number; b: number }>, false>>,

// tuple & array
Expect<Equal<Equal<[1, 2], [1, 2]>, true>>,
Expect<Equal<Equal<[1, 2], readonly [1, 2]>, false>>,
Expect<Equal<Equal<number[], number[]>, true>>,
Expect<Equal<Equal<number[], readonly number[]>, false>>,

// function
Expect<Equal<Equal<() => void, () => void>, true>>,
Expect<Equal<Equal<(x: number) => void, (x: number) => void>, true>>,
Expect<Equal<Equal<(x: number) => void, (x: string) => void>, false>>,

// special types
Expect<Equal<Equal<never, never>, true>>,
Expect<Equal<Equal<any, any>, true>>,
Expect<Equal<Equal<unknown, unknown>, true>>,
Expect<Equal<Equal<any, number>, false>>,
Expect<Equal<Equal<never, number>, false>>,
Expect<Equal<Equal<unknown, number>, false>>,
]
```

### 사전 지식

1. `extends`는 **할당(대입) 가능성**을 검사한다.

   <Code codeblock={{"lang":"typescript","value":"any extends string ? true : false // true\nstring extends any ? true : false // true"}} />

   흔히 TypeScript의 타입 시스템은 집합에 비유되곤 하지만, (구체 타입에 대하여)  `any`라는 특수 케이스 때문에 완벽히 동일하지는 않다. 따라서 `A extends B`가 `true`이고 `B extends A`가 `true`라고 이 둘이 동일하다는 **동등성을 보장하지는 못한다.**

### 풀이

<Collapsible>
  ```ts
  type Equal<A, B> =
    (<T>() => T extends A ? 1 : 2) extends
    (<T>() => T extends B ? 1 : 2)
      ? true
      : false;
  ```

  **해설**

  먼저 위 코드는 모든 타입 `T`에 대하여 A와 B의 `extends` 결과가 동일한 결과를 내는지 평가한다.

  `<T>() => T extends A ? 1 : 2`는 `<T>() =>`**`(T extends A ? 1 : 2)`**&#xB85C; 봐야 한다. \
  (\*함수 반환 타입이 extends보다 결합력이 높기 때문)\
  즉, `(모든 타입 extends A) extends (모든타입 extends B)`가 되어 A와 B가 모든 타입에 대해 개별적으로 같은 결과를 내는지 평가한다.\
  (모든 타입을 평가할 때, 유니온 분배 법칙이 적용된다.)

  **왜 `T extends A`가 아닌 함수 `<T>() =>T extends A`의 함수 형태를 취하는가?**

  TS에는 모든 타입을 표시할 수 있는 방법이 없기 때문이다. 만약 `T extends A`라고 작성하면 `T`를 제네릭으로 인식하여 타입 외부에서 제네릭 `T`를 제공받아야 한다.&#x20;

  하지만 `<T>() => T extends A`의 형태로 작성하게 되면 `<T>`를 통해 내부적으로 임의의 타입 `T`를 정의하게 되고, TS 컴파일러는 타입 `T`를 외부에서 받을 수 없으니 `T`에 모든 타입을 넣어 검사를 진행한다.
</Collapsible>
